================================================================================
KEPCO RPA 자동화 시스템 - 전체 코드
================================================================================

프로젝트 구조:
totalRPA/
├── main.py                # 메인 실행 파일
├── config.py              # 설정 관리
├── auth.py                # PowerGate 인증
├── downloader.py          # Excel 다운로드
├── processor.py           # 데이터 가공
├── mailer.py              # 메일 전송
├── requirements.txt       # Python 패키지 목록
├── build_exe.spec         # PyInstaller 설정
├── README.md              # 사용 설명서
└── 분류표.xlsx            # 분류 규칙 + 메일 설정

================================================================================
파일 1: config.py
================================================================================
"""
Configuration management for KEPCO RPA system
Handles path management for both development and exe packaging
"""

import os
import sys


def get_base_dir():
    """
    Get the base directory of the application
    Works for both development and PyInstaller exe
    """
    if getattr(sys, 'frozen', False):
        # Running as compiled exe
        return os.path.dirname(sys.executable)
    else:
        # Running as Python script
        return os.path.dirname(os.path.abspath(__file__))


def get_classification_file_path():
    """Get the path to 분류표.xlsx"""
    return os.path.join(get_base_dir(), '분류표.xlsx')


def get_output_dir():
    """Get the output directory (same as exe location)"""
    output_dir = get_base_dir()
    os.makedirs(output_dir, exist_ok=True)
    return output_dir


# Server URLs
WORK_MONITOR_URL = "http://work-monitor.kepco.co.kr"
BIZMAIL_URL = "http://bizmail.kepco.co.kr"
POWERGATE_WS_URI = "ws://127.0.0.1:21777"

# Work Monitor settings
DEPARTMENT_CODE = "4200"  # 강원본부
LIST_COUNT = 1000
PAGE = 1

# File format
FILE_FORMAT = "xls"  # Server returns HTML format regardless

# Timeouts
WEBSOCKET_TIMEOUT = 10
HTTP_TIMEOUT = 60

# Application info
APP_NAME = "KEPCO RPA"
APP_VERSION = "1.0.0"

================================================================================
파일 2: auth.py
================================================================================
"""
PowerGate authentication module
Handles WebSocket communication for SSO authentication
"""

import asyncio
import websockets
import requests
from config import POWERGATE_WS_URI, WEBSOCKET_TIMEOUT


async def get_powergate_cookies():
    """
    Connect to PowerGate and retrieve authentication cookies

    Returns:
        dict: Authentication cookies {pgsecuid, pgsecuid2, opv}
        None: If authentication fails
    """
    try:
        async with websockets.connect(POWERGATE_WS_URI, timeout=WEBSOCKET_TIMEOUT) as ws:
            # Send authentication request
            await ws.send(";;;GETCONFIGep;")

            # Receive response
            response = await ws.recv()
            print(f"[인증] PowerGate 응답 수신")

            # Parse response: {session};{uid};{user_id};{opv}
            parts = response.split(';')
            if len(parts) >= 4:
                session = parts[0]
                uid = parts[1]
                opv = parts[3]

                cookies = {
                    'pgsecuid': session,
                    'pgsecuid2': uid,
                    'opv': opv
                }

                print(f"[인증] 쿠키 획득 성공")
                return cookies
            else:
                print(f"[인증 오류] 응답 형식 오류: {response}")
                return None

    except asyncio.TimeoutError:
        print(f"[인증 오류] PowerGate 연결 시간 초과")
        return None
    except Exception as e:
        print(f"[인증 오류] {str(e)}")
        return None


def create_authenticated_session(cookies):
    """
    Create a requests Session with authentication cookies

    Args:
        cookies (dict): Authentication cookies from get_powergate_cookies()

    Returns:
        requests.Session: Authenticated session object
    """
    session = requests.Session()

    # Set cookies
    for key, value in cookies.items():
        session.cookies.set(key, value)

    # Set headers
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
        'Accept-Encoding': 'gzip, deflate',
        'Connection': 'keep-alive'
    })

    return session


def authenticate():
    """
    Complete authentication workflow

    Returns:
        requests.Session: Authenticated session
        None: If authentication fails
    """
    print("[인증] PowerGate 인증 시작...")

    # Get cookies via WebSocket
    cookies = asyncio.run(get_powergate_cookies())

    if cookies is None:
        print("[인증 실패] PowerGate 연결 실패")
        return None

    # Create authenticated session
    session = create_authenticated_session(cookies)
    print("[인증 완료] 세션 생성 완료\n")

    return session

================================================================================
파일 3: downloader.py
================================================================================
"""
Excel download module for KEPCO Work Monitor
Returns DataFrame directly for in-memory processing
"""

import requests
from datetime import datetime, timedelta
import pandas as pd
from io import BytesIO
from config import (
    WORK_MONITOR_URL, HTTP_TIMEOUT,
    PAGE, LIST_COUNT, DEPARTMENT_CODE
)


def download_excel_to_dataframe(session, date_from=None, date_to=None):
    """
    Download Excel from Work Monitor and return as DataFrame

    Args:
        session (requests.Session): Authenticated session
        date_from (str): Start date (YYYY-MM-DD), default: tomorrow
        date_to (str): End date (YYYY-MM-DD), default: tomorrow

    Returns:
        pandas.DataFrame: Downloaded data
        None: If download fails
    """
    print("=" * 60)
    print("엑셀 다운로드")
    print("=" * 60)

    # Set date range
    if not date_from:
        tomorrow = datetime.now() + timedelta(days=1)
        date_from = tomorrow.strftime("%Y-%m-%d")
    if not date_to:
        date_to = date_from

    date_range = f"{date_from} ~ {date_to}"

    print(f"\n[설정]")
    print(f"  페이지: {PAGE}")
    print(f"  항목 수: {LIST_COUNT}개")
    print(f"  날짜 범위: {date_range}")
    print(f"  담당부서: {DEPARTMENT_CODE} (강원본부)")

    # Update session headers
    session.headers.update({
        'Origin': WORK_MONITOR_URL,
        'Referer': f'{WORK_MONITOR_URL}/WORK/DAYWORK/list.php',
        'Content-Type': 'application/x-www-form-urlencoded',
        'Upgrade-Insecure-Requests': '1',
    })

    try:
        print(f"\n[다운로드] 요청 중...")

        # Request parameters from HAR
        data = {
            'page': str(PAGE),
            'listCnt': str(LIST_COUNT),
            'query_type': 'ALL',
            'gubun1': '',
            'gubun2': 'null',
            'dateRange': date_range,
            'selectOne': DEPARTMENT_CODE,
            'selectTwo': '',
            'selectDept': '',
            'keyword_gubun': '',
            'keyword': '',
            'stat_sel': '',
            'cancel_sel': '',
            'danger_sel': '',
            'day_select': '2'
        }

        # Download Excel
        response = session.post(
            f'{WORK_MONITOR_URL}/WORK/DAYWORK/excel_extract.php',
            data=data,
            stream=True,
            timeout=HTTP_TIMEOUT
        )

        if response.status_code == 200:
            # Read content into memory
            content = BytesIO(response.content)

            # Check if empty
            if len(response.content) == 0:
                print(f"\n[실패] 빈 파일 (데이터 없음)")
                print(f"        해당 날짜에 데이터가 없을 수 있습니다")
                return None

            # Check if HTML format (server returns HTML table)
            first_bytes = response.content[:100]
            is_html = b'<' in first_bytes or b'html' in first_bytes.lower()

            if is_html:
                print(f"[감지] HTML 형식 파일")
                print(f"[변환] HTML → DataFrame 변환 중...")

                # Read HTML table with first row as header
                dfs = pd.read_html(
                    BytesIO(response.content),
                    encoding='euc-kr',
                    header=0
                )

                if dfs and len(dfs) > 0:
                    df = dfs[0]
                    print(f"[성공] DataFrame 생성 완료!")
                    print(f"        행 수: {len(df)}")
                    print(f"        열 수: {len(df.columns)}")
                    print("=" * 60 + "\n")
                    return df
                else:
                    print(f"[실패] HTML 테이블을 찾을 수 없습니다")
                    return None
            else:
                # Read as Excel file
                print(f"[변환] Excel → DataFrame 변환 중...")
                df = pd.read_excel(content, engine='xlrd')
                print(f"[성공] DataFrame 생성 완료!")
                print(f"        행 수: {len(df)}")
                print(f"        열 수: {len(df.columns)}")
                print("=" * 60 + "\n")
                return df

        else:
            print(f"\n[실패] HTTP 오류")
            print(f"        상태 코드: {response.status_code}")
            print(f"        응답: {response.text[:200]}")
            return None

    except requests.exceptions.Timeout:
        print(f"\n[실패] 타임아웃 ({HTTP_TIMEOUT}초 초과)")
        return None

    except requests.exceptions.RequestException as e:
        print(f"\n[실패] 네트워크 오류: {e}")
        return None

    except Exception as e:
        print(f"\n[실패] 예상치 못한 오류: {e}")
        import traceback
        traceback.print_exc()
        return None

================================================================================
파일 4: processor.py (Part 1/2)
================================================================================
"""
Excel processing module with priority classification
Reads classification rules and mail config from 분류표.xlsx
"""

from openpyxl import load_workbook
from openpyxl.styles import Alignment, Font, PatternFill, Border, Side
from datetime import datetime, timedelta
import os
import pandas as pd
from config import get_classification_file_path, get_output_dir


def load_classification_and_mail_config(classification_file):
    """
    Load classification keywords from sheet 1 and mail config from sheet 2

    Returns:
        tuple: (keywords, special_rules, mail_config)

        keywords: {
            'A': ['키워드1', '키워드2', ...],  # 2순위(배전)
            'B': ['키워드1', '키워드2', ...],  # 1순위(배전)
            'C': ['키워드1', '키워드2', ...],  # 2순위(송변전)
            'D': ['키워드1', '키워드2', ...],  # 1순위(송변전)
            'E': ['키워드1', '키워드2', ...],  # 2순위(토건,ICT,기타)
            'F': ['키워드1', '키워드2', ...]   # 1순위(토건,ICT,기타)
        }

        special_rules: [
            {'column': 'D', 'keyword': '전력지사', 'priority': '3순위'},
            ...
        ]

        mail_config: {
            'from_name': str,       # A2: 작성자 이름
            'from_email': str,      # B2: 작성자 이메일
            'recipients': [str],    # D2~DN: 수신자 이메일 리스트
            'subject': str,         # E2: 메일 제목
            'body': str            # F2: 메일 본문
        }
    """
    print("=" * 60)
    print("분류표 로드")
    print("=" * 60)

    try:
        wb = load_workbook(classification_file)
        print(f"  파일 로드 성공: {classification_file}")
    except Exception as e:
        print(f"  [오류] 파일 로드 실패: {e}")
        raise

    # ========================================
    # Sheet 1: Classification keywords
    # ========================================
    ws1 = wb.worksheets[0]
    print(f"\n[시트 1] {ws1.title}")
    print(f"  크기: {ws1.max_row} 행 x {ws1.max_column} 열")

    keywords = {}

    # A~F 열의 키워드 수집 (2행부터, 1행은 헤더)
    for col_idx, col_letter in enumerate(['A', 'B', 'C', 'D', 'E', 'F'], start=1):
        col_keywords = []

        for row in range(2, ws1.max_row + 1):
            cell_value = ws1.cell(row=row, column=col_idx).value
            if cell_value and str(cell_value).strip():
                # 개행 문자가 있는 경우 여러 키워드로 분리
                keywords_in_cell = str(cell_value).strip().split('\n')
                for kw in keywords_in_cell:
                    kw = kw.strip()
                    if kw:
                        col_keywords.append(kw)

        keywords[col_letter] = col_keywords
        header = ws1.cell(row=1, column=col_idx).value
        print(f"  {col_letter}열 ({header}): {len(col_keywords)}개 키워드")

    # I, J, K 열에서 특별 우선순위 규칙 수집
    special_rules = []
    col_i_idx = 9   # I열: 대상 열
    col_j_idx = 10  # J열: 키워드
    col_k_idx = 11  # K열: 순위

    print(f"\n  특별 우선순위 규칙:")
    for row in range(2, ws1.max_row + 1):
        target_col = ws1.cell(row=row, column=col_i_idx).value
        keyword = ws1.cell(row=row, column=col_j_idx).value
        priority = ws1.cell(row=row, column=col_k_idx).value

        if target_col and keyword and priority:
            target_col = str(target_col).strip()
            keyword = str(keyword).strip()
            priority_str = f"{priority}순위"

            special_rules.append({
                'column': target_col,
                'keyword': keyword,
                'priority': priority_str
            })
            print(f"    규칙 {len(special_rules)}: {target_col}열에 '{keyword}' 포함 → {priority_str}")

    # ========================================
    # Sheet 2: Mail configuration
    # ========================================
    ws2 = wb.worksheets[1] if len(wb.worksheets) >= 2 else None

    mail_config = None

    if ws2:
        print(f"\n[시트 2] {ws2.title}")
        print(f"  크기: {ws2.max_row} 행 x {ws2.max_column} 열")

        # A2: 작성자 이름
        from_name = ws2.cell(row=2, column=1).value

        # B2: 작성자 이메일
        from_email = ws2.cell(row=2, column=2).value

        # D2~DN: 수신자 이메일 (빈 셀 나올 때까지)
        recipients = []
        row_num = 2
        while True:
            email = ws2.cell(row=row_num, column=4).value
            if email is None or str(email).strip() == '':
                break
            recipients.append(str(email).strip())
            row_num += 1

        # E2: 메일 제목
        subject = ws2.cell(row=2, column=5).value

        # F2: 메일 본문
        body = ws2.cell(row=2, column=6).value

        mail_config = {
            'from_name': str(from_name).strip() if from_name else '',
            'from_email': str(from_email).strip() if from_email else '',
            'recipients': recipients,
            'subject': str(subject).strip() if subject else '',
            'body': str(body).strip() if body else ''
        }

        print(f"\n  메일 설정:")
        print(f"    발신자: {mail_config['from_name']} <{mail_config['from_email']}>")
        print(f"    수신자: {len(mail_config['recipients'])}명")
        for idx, rcpt in enumerate(mail_config['recipients'], 1):
            print(f"      {idx}. {rcpt}")
        print(f"    제목: {mail_config['subject']}")
        print(f"    본문: {mail_config['body'][:50]}..." if len(mail_config['body']) > 50 else f"    본문: {mail_config['body']}")
    else:
        print(f"\n  [경고] 시트 2가 없습니다. 기본 메일 설정 사용")

    wb.close()
    print("=" * 60 + "\n")

    return keywords, special_rules, mail_config


def contains_keyword(text, keyword_list):
    """텍스트에 키워드 리스트 중 하나라도 포함되어 있는지 확인"""
    if not text:
        return False

    text = str(text).strip()
    for keyword in keyword_list:
        if keyword in text:
            return True
    return False


def determine_priority(row_data, keywords, special_rules):
    """
    행 데이터를 기반으로 점검순위 결정

    Args:
        row_data: dict with all column data (key: column letter, value: cell value)
        keywords: 분류표에서 로드한 키워드 딕셔너리
        special_rules: 특별 우선순위 규칙 리스트

    Returns:
        str: '1순위', '2순위', '3순위'
    """
    category = row_data.get('H', '')  # 대분류
    col_f = row_data.get('F', '')     # 공사명
    col_o = row_data.get('O', '')     # 기타

    # F열과 O열을 합쳐서 검색
    search_text = f"{col_f} {col_o}"

    # 기본 분류 규칙 적용
    priority = "3순위"  # 기본값

    # 1. 배전
    if category == "배전":
        if contains_keyword(search_text, keywords['B']):
            priority = "1순위"
        elif contains_keyword(search_text, keywords['A']):
            priority = "2순위"

    # 2. 송전, 변전, 변전(변환)
    elif category in ["송전", "변전", "변전(변환)"]:
        if contains_keyword(search_text, keywords['D']):
            priority = "1순위"
        elif contains_keyword(search_text, keywords['C']):
            priority = "2순위"

    # 3. 토건, ICT, 기타
    elif category in ["토건", "ICT", "기타"]:
        if contains_keyword(search_text, keywords['F']):
            priority = "1순위"
        elif contains_keyword(search_text, keywords['E']):
            priority = "2순위"

    # 특별 우선순위 규칙 적용 (순서대로 적용, 나중 규칙이 우선)
    for rule in special_rules:
        target_col = rule['column']
        keyword = rule['keyword']
        rule_priority = rule['priority']

        # 해당 열의 값 가져오기
        cell_value = row_data.get(target_col, '')

        if not cell_value:
            continue

        cell_value_str = str(cell_value)

        # 키워드가 큰따옴표로 감싸져 있으면 정확히 일치하는 경우만 매칭
        if keyword.startswith('"') and keyword.endswith('"'):
            exact_keyword = keyword.strip('"')
            if cell_value_str == exact_keyword:
                priority = rule_priority
        else:
            # 큰따옴표가 없으면 포함 여부로 매칭
            if keyword in cell_value_str:
                priority = rule_priority

    return priority


def index_to_col_letter(idx):
    """인덱스를 열 문자로 변환 (1=A, 2=B, ...)"""
    result = ""
    while idx > 0:
        idx -= 1
        result = chr(ord('A') + idx % 26) + result
        idx //= 26
    return result


def col_letter_to_index(letter):
    """열 문자를 인덱스로 변환 (A=1, B=2, ...)"""
    result = 0
    for char in letter.upper():
        result = result * 26 + (ord(char) - ord('A') + 1)
    return result

================================================================================
파일 4: processor.py (Part 2/2)
================================================================================

def process_dataframe(df, keywords, special_rules):
    """
    Process DataFrame and save as Excel with priority classification

    Args:
        df: pandas DataFrame from download
        keywords: classification keywords
        special_rules: special priority rules

    Returns:
        str: Output file path
    """
    print("=" * 60)
    print("데이터 가공")
    print("=" * 60)

    print(f"\n  원본 크기: {len(df)} 행 x {len(df.columns)} 열")

    # 1. 불필요한 열 삭제 (DataFrame에서 직접)
    print(f"\n  불필요한 열 삭제 중...")

    # 열 인덱스로 삭제할 범위 계산 (0-based index)
    # P~T: 15~19, W~Y: 22~24, AB~AE: 27~30
    cols_to_drop = []

    # P(16열) ~ T(20열)
    if len(df.columns) >= 20:
        cols_to_drop.extend(df.columns[15:20].tolist())

    # W(23열) ~ Y(25열)
    if len(df.columns) >= 25:
        cols_to_drop.extend(df.columns[22:25].tolist())

    # AB(28열) ~ AE(31열)
    if len(df.columns) >= 31:
        cols_to_drop.extend(df.columns[27:31].tolist())

    df = df.drop(columns=cols_to_drop, errors='ignore')
    print(f"  삭제 후 크기: {len(df)} 행 x {len(df.columns)} 열")

    # 2. 점검순위 열 추가 및 자동 할당
    print(f"\n  점검순위 자동 할당 중... (총 {len(df)}개 행)")

    priorities = []
    priority_counts = {"1순위": 0, "2순위": 0, "3순위": 0}

    for idx, row in df.iterrows():
        # 행 데이터를 열 문자(A, B, C, ...) 기준 딕셔너리로 변환
        row_data = {}
        for col_idx, col_name in enumerate(df.columns):
            col_letter = index_to_col_letter(col_idx + 1)
            row_data[col_letter] = row[col_name]

        priority = determine_priority(row_data, keywords, special_rules)
        priorities.append(priority)
        priority_counts[priority] += 1

        if (idx + 1) % 100 == 0:
            print(f"    진행중... {idx + 1}/{len(df)} 행")

    # 점검순위 열 추가
    df['점검순위'] = priorities

    print(f"\n  점검순위 할당 완료:")
    print(f"    1순위: {priority_counts['1순위']}건")
    print(f"    2순위: {priority_counts['2순위']}건")
    print(f"    3순위: {priority_counts['3순위']}건")

    # 3. A열 기준 오름차순 정렬
    print(f"\n  첫 번째 열 기준 정렬 중...")
    df = df.sort_values(by=df.columns[0], ascending=True)

    # 4. 최종 파일 저장 (openpyxl로 서식 적용)
    print(f"\n  Excel 서식 적용 및 저장 중...")

    output_dir = get_output_dir()
    tomorrow = datetime.now() + timedelta(days=1)
    output_filename = tomorrow.strftime('%y%m%d') + ' 공사현장 점검 우선순위 리스트.xlsx'
    output_filepath = os.path.join(output_dir, output_filename)

    # DataFrame을 Excel로 저장
    with pd.ExcelWriter(output_filepath, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Sheet1')

        # 워크시트 가져오기
        wb = writer.book
        ws = writer.sheets['Sheet1']

        # 열 너비 적용
        column_widths = {
            'A': 6.66, 'B': 9.83, 'C': 8.83, 'D': 13.83, 'E': 12.16,
            'F': 21.33, 'G': 14.5, 'H': 13.0, 'I': 13.0, 'J': 17.5,
            'K': 8.5, 'L': 13.0, 'M': 13.0, 'N': 21.83, 'O': 28.33,
            'P': 17.16, 'Q': 10.0, 'R': 10.16, 'S': 10.0, 'T': 11.5
        }

        for col_letter, width in column_widths.items():
            if col_letter_to_index(col_letter) <= len(df.columns):
                ws.column_dimensions[col_letter].width = width

        # 전체 셀 가운데 정렬 + 텍스트 자동 줄바꿈
        center_alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)

        for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
            for cell in row:
                cell.alignment = center_alignment

        # 제목행 스타일 (1행)
        bold_font = Font(bold=True)
        gray_fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")

        for col in range(1, ws.max_column + 1):
            cell = ws.cell(row=1, column=col)
            cell.font = bold_font
            cell.fill = gray_fill

        # 우선순위별 행 배경색 적용 (2행부터)
        priority_colors = {
            '1순위': 'FFFF00',  # 노란색
            '2순위': 'F7B9AF'   # 분홍색
        }

        priority_col_idx = len(df.columns)  # 마지막 열 (점검순위)

        for row_idx in range(2, ws.max_row + 1):
            priority = ws.cell(row=row_idx, column=priority_col_idx).value

            if priority in priority_colors:
                color = priority_colors[priority]
                fill = PatternFill(start_color=color, end_color=color, fill_type="solid")

                for col in range(1, ws.max_column + 1):
                    ws.cell(row=row_idx, column=col).fill = fill

        # 모든 셀에 테두리 적용
        thin_border = Border(
            left=Side(style='thin', color='000000'),
            right=Side(style='thin', color='000000'),
            top=Side(style='thin', color='000000'),
            bottom=Side(style='thin', color='000000')
        )

        for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
            for cell in row:
                cell.border = thin_border

        # 틀 고정 (1행 고정)
        ws.freeze_panes = 'A2'

        # 자동 필터 적용
        ws.auto_filter.ref = ws.dimensions

    print(f"  저장 완료: {output_filename}")
    print("=" * 60 + "\n")

    return output_filepath

================================================================================
파일 5: mailer.py
================================================================================
"""
BizMail sending module
Uses dynamic mail configuration from 분류표.xlsx sheet 2
"""

import requests
import os
from datetime import datetime
import uuid
from config import BIZMAIL_URL, HTTP_TIMEOUT


def generate_temp_key():
    """Generate temporary key for mail tracking (24 chars)"""
    return uuid.uuid4().hex[:24]


def upload_files(session, file_paths):
    """
    Upload file attachments

    Args:
        session (requests.Session): Authenticated session
        file_paths (list): List of file paths to upload

    Returns:
        list: Uploaded file info [{'filekey', 'filename', 'size'}, ...]
    """
    uploaded_files = []

    if not file_paths:
        return uploaded_files

    print(f"\n  파일 업로드 중... ({len(file_paths)}개)")

    for filepath in file_paths:
        if not os.path.exists(filepath):
            print(f"    [경고] 파일 없음: {filepath}")
            continue

        filename = os.path.basename(filepath)
        filesize = os.path.getsize(filepath)

        # Internal filename (plupload format)
        internal_name = f"o_{uuid.uuid4().hex[:24]}{os.path.splitext(filename)[1]}"

        try:
            with open(filepath, 'rb') as f:
                files = {
                    'file': (filename, f, 'application/octet-stream')
                }
                data = {
                    'name': internal_name,
                    'chunk': '0',
                    'chunks': '1',
                    'filename': filename
                }

                resp = session.post(
                    f'{BIZMAIL_URL}/mail/json/uploadFile.do?_csrf=',
                    files=files,
                    data=data,
                    timeout=HTTP_TIMEOUT
                )

                result = resp.json()

                if result.get('result') == 1 and 'filekey' in result:
                    filekey = result['filekey'][0]
                    uploaded_files.append({
                        'filekey': filekey,
                        'filename': filename,
                        'size': filesize
                    })
                    print(f"    [완료] {filename}")
                else:
                    print(f"    [실패] {filename}: {result}")

        except Exception as e:
            print(f"    [오류] {filename}: {e}")

    print(f"  업로드 완료: {len(uploaded_files)}개\n")
    return uploaded_files


def send_bizmail(session, mail_config, attachment_paths=None):
    """
    Send email via KEPCO BizMail system

    Args:
        session (requests.Session): Authenticated session
        mail_config (dict): Mail configuration from 분류표.xlsx sheet 2
            {
                'from_name': str,
                'from_email': str,
                'recipients': [str, ...],
                'subject': str,
                'body': str
            }
        attachment_paths (list): Optional list of file paths to attach

    Returns:
        dict: {'success': bool, 'message': str, 'response': dict}
    """
    print("=" * 60)
    print("메일 전송")
    print("=" * 60)

    # Update session headers
    session.headers.update({
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Origin': BIZMAIL_URL,
        'Referer': f'{BIZMAIL_URL}/mail/list.do',
        'X-Requested-With': 'XMLHttpRequest',
    })

    try:
        # Step 1: Session validation
        print(f"\n  세션 확인 중...")
        timestamp = int(datetime.now().timestamp() * 1000)
        session_url = f"{BIZMAIL_URL}/common/json/session/check.do?_={timestamp}"

        session_resp = session.get(session_url, timeout=HTTP_TIMEOUT)
        session_data = session_resp.json()

        if not session_data.get('alive'):
            print("  [실패] 세션 만료")
            return {"success": False, "message": "세션 만료"}

        print("  세션 정상")

        # Step 2: File upload
        uploaded_files = upload_files(session, attachment_paths or [])

        # Prepare attachment parameters
        attach_size = sum(f['size'] for f in uploaded_files)
        attach_list = ':'.join([f"{f['filename']}:{f['size']}:1:0" for f in uploaded_files])
        attachments_param = ':'.join([f"{f['filekey']}:0:1:0" for f in uploaded_files])

        # Step 3: Receiver validation
        print(f"  수신자 검증 중...")

        # Convert body to HTML format if not already
        body_html = mail_config['body']
        if not body_html.strip().startswith('<html>'):
            body_html = f"""<html><head><style type="text/css">
p {{padding:0;margin:0;}}
</style>
</head><body><div class="sensEdContentAreaCls" data-id="sensEdContentArea" style="color:#000;line-height:150%;font-size:12pt;font-family:돋움 !important;padding:0;margin:0;">
{body_html}
</div></body></html>"""

        receiver_data = {
            'subject': mail_config['subject'],
            'subjecthead': '-1',
            'content': body_html,
            'fromaddr': mail_config['from_email'],
            'attach_size': str(attach_size),
            'attach_list': attach_list,
        }

        # Add recipients
        for recipient in mail_config['recipients']:
            receiver_data['to'] = recipient

        receiver_resp = session.post(
            f"{BIZMAIL_URL}/mail/json/receiverCheck.do",
            data=receiver_data,
            headers={'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'},
            timeout=HTTP_TIMEOUT
        )

        receiver_result = receiver_resp.json()
        print(f"    수신자: {receiver_result.get('receiver_count', 0)}명")

        if not receiver_result.get('permission'):
            print("  [실패] 발송 권한 없음")
            return {"success": False, "message": "발송 권한 없음"}

        # Step 4: Send email
        print(f"\n  메일 발송 중...")

        # Generate temporary key
        temp_key = generate_temp_key()
        secure_value = temp_key[:10]
        current_date = datetime.now().strftime("%Y-%m-%d")

        # Complete parameters from HAR analysis
        send_data = {
            # Basic info
            'fromaddr': mail_config['from_email'],
            'fromname': mail_config['from_name'],
            'subject': mail_config['subject'],
            'subjecthead': '-1',
            'body': body_html,

            # Recipients
            '_tome': 'on',
            '_is_report': 'on',

            # Temporary key & security
            'tempKey': temp_key,
            'secureValue': secure_value,
            'ukey': '',
            'first': '0',
            'tempsave': '0',

            # Attachments
            'attachments': attachments_param,

            # Reservation & approval
            'reserverTime': '',
            'req_reserverTime': '',
            'mail_cancel_time': '0',
            'approval_flag': '0',
            'isPermissionMail': '',
            'reserveEndTime': '',
            'repeat_type': '',
            'repeat_cycle': '0',
            'repeat_dayofweek': '',
            'repeat_mailkey': '',
            'myTemplateKey': '',

            # Link attachment
            'islinkattach': '0',
            'use_bigfile_password': '0',
            'linkattach_filesize': '',
            'linkattach_downterm': '',
            'temp_save_bigfile': '1',

            # Approval
            'approvalkey': '',
            'ap_send_type': '0',
            'approver': '',
            'is_ap': '0',

            # Options
            '_is_each': 'on',
            '_important': 'on',
            '_use_sign': 'on',
            'sign': 'mail_sign',

            # Reservation time
            'reserveTime': current_date,
            'c_reserveTime': current_date,
            'hour_c': '23',
            'minute_c': '50',

            # Editor
            'editor_type': '1',
            'characterset': 'utf-8',

            # Security & receipt
            '_is_secure': 'on',
            'is_receipt': '1',
            '_is_receipt': 'on',

            # Save to sent mail (important!)
            'is_save': '1',
            '_is_save': 'on',

            # Notifications & SMS
            '_alarm': 'on',
            '_sms': 'on',

            # Reply request
            'replyRequestTime': current_date,
            'hour_r': '23',
            'minute_r': '50',

            # Approval report
            'apUser': '',
            'apUserText': '',
            '_apReport': 'on',

            # Edit
            'editHtml': '',
            'editText': '',
            'divText': '',
        }

        # Add recipients
        for recipient in mail_config['recipients']:
            send_data['to'] = recipient

        print(f"    발신: {mail_config['from_name']} <{mail_config['from_email']}>")
        print(f"    수신: {len(mail_config['recipients'])}명")
        for rcpt in mail_config['recipients']:
            print(f"      - {rcpt}")
        print(f"    제목: {mail_config['subject']}")
        print(f"    첨부: {len(uploaded_files)}개")

        # Send!
        send_resp = session.post(
            f"{BIZMAIL_URL}/mail/json/send.do",
            data=send_data,
            headers={'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'},
            timeout=HTTP_TIMEOUT
        )

        send_result = send_resp.json()

        if send_result.get('code') == 1:
            print(f"\n  [성공] 메일 발송 완료!")
            print(f"    발송 키: {send_result.get('sent_mail_key', 'N/A')}")
            print(f"    저장 키: {send_result.get('save_mail_key', 'N/A')}")
            print("=" * 60 + "\n")
            return {"success": True, "message": "발송 완료", "response": send_result}
        else:
            print(f"\n  [실패] 발송 실패")
            print(f"    응답: {send_result}")
            print("=" * 60 + "\n")
            return {"success": False, "message": "발송 실패", "response": send_result}

    except requests.exceptions.Timeout:
        print(f"\n  [실패] 타임아웃 ({HTTP_TIMEOUT}초 초과)")
        return {"success": False, "message": "타임아웃"}

    except requests.exceptions.RequestException as e:
        print(f"\n  [실패] 네트워크 오류: {e}")
        return {"success": False, "message": str(e)}

    except Exception as e:
        print(f"\n  [실패] 예상치 못한 오류: {e}")
        import traceback
        traceback.print_exc()
        return {"success": False, "message": str(e)}

================================================================================
파일 6: main.py
================================================================================
"""
KEPCO RPA Main Program
Automated workflow: Download → Process → Send Email

실행 방법:
    python main.py

요구사항:
    - PowerGate 실행 중
    - 분류표.xlsx 파일 존재 (같은 디렉토리)
    - 인터넷 연결 (사내망)
"""

from datetime import datetime
import sys
import os

# Import modules
import auth
import downloader
import processor
import mailer
from config import get_classification_file_path, get_output_dir


def print_header():
    """Print program header"""
    print("\n" + "=" * 60)
    print("KEPCO RPA 자동화 시스템")
    print("=" * 60)
    print(f"시작 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"출력 경로: {get_output_dir()}")
    print("=" * 60 + "\n")


def print_footer(success):
    """Print program footer"""
    print("\n" + "=" * 60)
    print("작업 완료")
    print("=" * 60)
    print(f"종료 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"결과: {'✅ 성공' if success else '❌ 실패'}")
    print("=" * 60 + "\n")


def main():
    """Main workflow execution"""
    success = False

    try:
        print_header()

        # ============================================
        # Step 1: Authentication
        # ============================================
        print("⚡ [1/4] PowerGate 인증")
        print("-" * 60)

        session = auth.authenticate()

        if session is None:
            print("\n❌ 인증 실패")
            print("\n해결 방법:")
            print("  1. PowerGate가 실행 중인지 확인하세요")
            print("  2. 작업 관리자에서 PowerGate 프로세스를 확인하세요")
            print("  3. PowerGate를 재시작하고 다시 시도하세요")
            return

        # ============================================
        # Step 2: Download Excel
        # ============================================
        print("\n⚡ [2/4] Excel 다운로드")
        print("-" * 60)

        df = downloader.download_excel_to_dataframe(session)

        if df is None:
            print("\n❌ 다운로드 실패")
            print("\n해결 방법:")
            print("  1. 사내망에 연결되어 있는지 확인하세요")
            print("  2. Work Monitor 서버 접근 권한을 확인하세요")
            print("  3. 해당 날짜에 데이터가 있는지 확인하세요")
            return

        # ============================================
        # Step 3: Load classification and mail config
        # ============================================
        print("\n⚡ [3/4] 데이터 가공")
        print("-" * 60)

        classification_file = get_classification_file_path()

        if not os.path.exists(classification_file):
            print(f"\n❌ 분류표 파일을 찾을 수 없습니다")
            print(f"   경로: {classification_file}")
            print("\n해결 방법:")
            print("  1. 분류표.xlsx 파일이 프로그램과 같은 폴더에 있는지 확인하세요")
            return

        # Load classification keywords and mail config
        keywords, special_rules, mail_config = processor.load_classification_and_mail_config(
            classification_file
        )

        if mail_config is None:
            print("\n❌ 메일 설정을 찾을 수 없습니다")
            print("\n해결 방법:")
            print("  1. 분류표.xlsx 파일에 시트 2가 있는지 확인하세요")
            print("  2. 시트 2에 메일 설정 정보가 올바르게 입력되어 있는지 확인하세요")
            return

        # Process DataFrame and save to Excel
        output_file = processor.process_dataframe(df, keywords, special_rules)

        if output_file is None or not os.path.exists(output_file):
            print("\n❌ 데이터 가공 실패")
            return

        print(f"\n✅ 가공 완료: {os.path.basename(output_file)}")

        # ============================================
        # Step 4: Send email
        # ============================================
        print("\n⚡ [4/4] 메일 전송")
        print("-" * 60)

        result = mailer.send_bizmail(
            session=session,
            mail_config=mail_config,
            attachment_paths=[output_file]
        )

        if result['success']:
            print("\n✅ 모든 작업이 성공적으로 완료되었습니다!")
            print(f"\n최종 결과물:")
            print(f"  파일: {os.path.basename(output_file)}")
            print(f"  위치: {output_file}")
            print(f"\n메일 발송:")
            print(f"  수신자: {len(mail_config['recipients'])}명")
            print(f"  제목: {mail_config['subject']}")
            success = True
        else:
            print(f"\n❌ 메일 전송 실패: {result['message']}")
            print(f"\n파일은 저장되었습니다:")
            print(f"  {output_file}")

    except KeyboardInterrupt:
        print("\n\n⚠️  사용자가 작업을 중단했습니다")

    except Exception as e:
        print(f"\n❌ 예상치 못한 오류가 발생했습니다:")
        print(f"   {str(e)}")
        print("\n상세 오류:")
        import traceback
        traceback.print_exc()

    finally:
        print_footer(success)


if __name__ == '__main__':
    """
    KEPCO RPA 자동화 프로그램

    기능:
        1. Work Monitor에서 사전신고정보 Excel 다운로드
        2. 분류표 기준으로 점검순위 자동 분류
        3. BizMail로 자동 발송

    설정:
        - config.py: 기본 설정 (날짜, 부서코드 등)
        - 분류표.xlsx:
            * 시트 1: 분류 키워드 규칙
            * 시트 2: 메일 설정 (발신자, 수신자, 제목, 본문)

    실행 환경:
        - PowerGate 실행 필요
        - KEPCO 사내망 접속 필요
        - 분류표.xlsx 파일 필요 (같은 디렉토리)

    출력:
        - 파일 위치: 프로그램과 같은 폴더
        - 파일명: YYMMDD 공사현장 점검 우선순위 리스트.xlsx
    """
    try:
        main()
    except Exception as e:
        print(f"\n프로그램 실행 중 치명적 오류 발생: {e}")
        sys.exit(1)

================================================================================
파일 7: requirements.txt
================================================================================
# KEPCO RPA Dependencies

# Core dependencies
websockets>=12.0
requests>=2.31.0
pandas>=2.0.0
openpyxl>=3.1.0
lxml>=4.9.0

# Optional (for legacy Excel format support)
xlrd>=2.0.0

# Note: Standard library modules used (no install needed)
# - asyncio
# - os
# - sys
# - datetime
# - uuid
# - io

================================================================================
파일 8: build_exe.spec
================================================================================
# -*- mode: python ; coding: utf-8 -*-
"""
PyInstaller spec file for KEPCO RPA
Build command: pyinstaller build_exe.spec
"""

block_cipher = None

a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=[],
    datas=[
        ('분류표.xlsx', '.'),  # Bundle classification file
    ],
    hiddenimports=[
        'websockets',
        'requests',
        'pandas',
        'openpyxl',
        'lxml',
        'xlrd',
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='KEPCO_RPA',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=True,  # Show console window
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

================================================================================
END OF ALL_CODE.txt
================================================================================
